<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Math4Programmers</title>
    <style>
        /* General styles for the body */
        body {
            font-family: 'JetBrains Mono', monospace;
            background-color: #eafff7; /* Gruvbox background */
            color: #000000; /* Gruvbox foreground */
            margin: 0;
            padding: 20px;
            line-height: 1.6;
            overflow-x: hidden;
        }

        /* Style for the section */
        .section {
            padding: 30px;
            border: 4px solid #000000; /* Gruvbox dark gray */
            border-radius: 20px;
            background-color: #f9f1c8; /* Gruvbox light background */
            margin: 40px auto;
            max-width: 800px;
            box-shadow: 15px 15px 0px rgb(0, 0, 0);
        }

        /* Style for headings */
        .section h2 {
            font-size: 1.8em;
            color: #03657a; /* Gruvbox blue */
            margin-top: 0;
            border-bottom: 2px solid #cc241d; /* Gruvbox red */
            padding-bottom: 10px;
            font-weight: bold;
        }

        .section h3 {
            font-size: 1.4em;
            color: #03657a; /* Gruvbox blue */
            padding-bottom: 5px;
            margin-top: 20px;
            margin-bottom: 10px;
            font-weight: bold;
        }

        /* Style for paragraphs */
        .section p {
            margin: 0 0 15px;
            padding: 0;
        }

        /* Style for code blocks */
        pre {
            background-color: #3b4639; /* Gruvbox light */
            border: 2px solid #000000; /* Gruvbox black */
            padding: 15px;
            overflow-x: auto;
            border-radius: 10px;
            box-shadow: 5px 5px 0px rgb(0, 0, 0);
            font-size: 1em;
            font-family: 'Courier New', Courier, monospace;
            color: #EADBB2; /* Gruvbox foreground */
        }

        code {
            background-color: #3b4639; /* Gruvbox light */
            padding: 2px 4px;
            border-radius: 3px;
        }

        /* Style for strong text */
        strong {
            color: #cc241d; /* Gruvbox red-ish */
            font-weight: bold;
        }

        /* Additional styles for emphasis */
        .section pre code {
            display: block;
            white-space: pre-wrap; /* Allow long lines to wrap */
        }

        /* Style for the container */
        .section-container {
            max-width: 100%;
            margin: 0 auto;
        }

        /* Styles for the navigation menu */
        #navMenu {
            position: fixed;
            top: 0;
            right: 0;
            width: 200px;
            height: 100%;
            background-color: #f9f1c8;
            padding: 20px;
            box-shadow: -15px 0px 0px rgb(0, 0, 0);
            overflow-y: auto;
            transform: translateX(100%);
            transition: transform 0.3s ease-in-out;
            z-index: 1000; /* Ensure the menu is on top */
        }
        #navMenu.show {
            transform: translateX(0);
        }
        #navMenu ul {
            list-style-type: none;
            padding: 0;
        }
        #navMenu ul li a {
            display: block;
            padding: 10px 0;
            color: #000;
            text-decoration: none;
        }

        /* Styles for the menu button */
        #menuButton {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: #f9f1c8;
            border: 4px solid #000000;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            text-align: center;
            line-height: 50px;
            font-size: 24px;
            color: #000000;
            cursor: pointer;
            transition: right 0.3s ease-in-out;
            z-index: 1001; /* Ensure the button is on top */
        }
        #menuButton.show {
            right: 220px;
        }

        /* Header table styling */
        .header {
            width: 100%;
            max-width: 800px; /* Match section max-width */
            margin: 0 auto; /* Center align */
            border-collapse: collapse;
            border-spacing: 0;
        }

        table {
            width: 100%;
        }

        th, td {
            border: 4px solid #000000; /* Thick black border */
            padding: 10px;
            text-align: center;
        }

        /* Title and subtitle styling */
        .title {
            font-size: 2.5em;
            color: #03657a; /* Title color */
            text-align: left;
        }

        .subtitle {
            font-size: 1.2em;
            color: #3c3836; /* Subtitle color */
            text-align: left;
        }

        /* Column widths */
        .width-auto {
            width: 75%; /* 3/4 of the space */
            text-align: left; /* Align text to the left */
        }

        .width-min {
            width: 25%; /* 1/4 of the space */
            text-align: right; /* Align text to the right */
        }

        /* Link styling */
        a {
            color: #03657a; /* Link color */
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        /* Time styling */
        time {
            white-space: pre; /* Preserve formatting for date */
        }
    </style>
</head>
<body>
    <table class="header">
        <tbody>
            <tr>
                <td colspan="2" rowspan="2" class="width-auto">
                    <h1 class="title">Mathematical Notation in Code</h1>
                    <span class="subtitle">From Symbols to Implementation: A Programmer’s Guide to Integrating Math Notation</span>
                </td>
            </tr>
            <tr>
            </tr>
            <tr>
                <th class="width-min">Author</th>
                <td class="width-auto"><a href="https://github.com/AlRodriguezGar14"><cite>Alberto Rodriguez</cite></a></td>
            </tr>
        </tbody>
    </table>

    <div id="menuButton">☰</div>

<div id="navMenu">
    <ul>
        <li><a href="#section1">1. Σ (Sigma) - Summation</a></li>
        <li><a href="#section2">2. ∏ (Pi) - Product</a></li>
        <li><a href="#section3">3. √ - Square Root</a></li>
        <li><a href="#section4">4. ∫ - Integral</a></li>
        <li><a href="#section5">5. d/dx - Derivative</a></li>
        <li><a href="#section6">6. lim - Limit</a></li>
        <li><a href="#section7">7. ∀ - For All</a></li>
        <li><a href="#section8">8. {…} - Set Notation</a></li>
        <li><a href="#section9">9. ∈ - Element of</a></li>
        <li><a href="#section10">10. { | property} - Set Builder Notation</a></li>
        <li><a href="#section11">11. ⊆ - Subset</a></li>
        <li><a href="#section12">12. ∪ - Union</a></li>
        <li><a href="#section13">13. ∩ - Intersection</a></li>
        <li><a href="#section14">14. ∂ - Partial Derivative</a></li>
        <li><a href="#section15">15. ∇ - Gradient</a></li>
        <li><a href="#section16">16. ≈ - Approximately Equal</a></li>
        <li><a href="#section17">17. ∞ - Infinity</a></li>
        <li><a href="#section18">18. ∃ - There Exists</a></li>
        <li><a href="#section19">19. ⇒ and ⇔ - Implication and Equivalence</a></li>
        <li><a href="#section20">20. Matrix Operations</a></li>
        <li><a href="#section21">21. Partial Derivatives and Gradients in Neural Networks</a></li>
        <li><a href="#section22">22. Activation Functions</a></li>
        <li><a href="#section23">23. Probability and Statistics in Machine Learning</a></li>
        <li><a href="#section24">24. Optimization Techniques</a></li>
        <li><a href="#section25">25. Trigonometric Functions</a></li>
        <li><a href="#section26">Basic Introduction</a></li>
        <li><a href="#section27">27. Superscript Notation (i) and [l]</a></li>
        <li><a href="#section28">28. Size Notations (m, nx, ny, n[l]h, L)</a></li>
        <li><a href="#section29">29. Matrix and Vector Notations (X, x(i), Y, y(i), W[l], b[l], ŷ)</a></li>
        <li><a href="#section30">30. Activation Functions and Forward Propagation</a></li>
        <li><a href="#section31">31. Cost Functions J(x, W, b, y) or J(ŷ, y)</a></li>
        <li><a href="#section32">32. Jacobian Matrix (J)</a></li>
        <li><a href="#section33">33. Hessian Matrix (H)</a></li>
        <li><a href="#section34">34. Eigenvalues and Eigenvectors</a></li>
        <li><a href="#section35">35. Matrix Inverses and Determinants</a></li>
        <li><a href="#section36">36. L'Hôpital's Rule</a></li>
        <li><a href="#section37">37. Implicit Differentiation</a></li>
        <li><a href="#section38">38. Chain Rule</a></li>
        <li><a href="#section39">39. Multivariable Calculus</a></li>
        <li><a href="#section40">40. Big-O Notation (O)</a></li>
    </ul>
</div>

<div class="section" id="section1">
    <h2>1. Σ (Sigma) - Summation</h2>
    <h3>Basic Introduction</h3>
    <p>The Σ (Sigma) symbol represents summation in mathematics. It's used to describe the sum of a sequence of numbers.</p>

    <h3>Simple Example</h3>
    <pre><code>
 5
 Σ i = 1 + 2 + 3 + 4 + 5 = 15
i=1
    </code></pre>
    <p>This means "sum up the values of i, where i goes from 1 to 5".</p>

    <h3>Advanced Explanation</h3>
    <p>Summation is a fundamental operation in calculus and discrete mathematics. It can represent finite or infinite series and is crucial in areas like probability, statistics, and numerical analysis.</p>

    <h3>Complex Example: Sum of Natural Numbers</h3>
    <p><strong>Mathematical Notation:</strong></p>
<pre><code>
    n
   Σ  i = 1 + 2 + ... + n = n(n + 1) / 2
   i=1
</code></pre>

    <p><strong>Meaning:</strong> The sum of integers from 1 to n.</p>

    <p><strong>C Implementation:</strong></p>
    <pre><code>
int sum_of_natural_numbers(int n) {
    return n * (n + 1) / 2;
}
    </code></pre>

    <p><strong>Iterative Implementation:</strong></p>
    <pre><code>
int sum_of_natural_numbers_iterative(int n) {
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        sum += i;
    }
    return sum;
}
    </code></pre>

    <h3>Additional Example: Summation with a Step Size</h3>
    <p>Sometimes summations include a step size other than 1.</p>

    <p><strong>Mathematical Notation:</strong></p>
    <pre><code>
 Σ (i=1 to 10, step 2) of i = 1 + 3 + 5 + 7 + 9 = 25
    </code></pre>

    <p><strong>Meaning:</strong> Sum the numbers from 1 to 10 with a step size of 2.</p>

    <p><strong>C Implementation:</strong></p>
    <pre><code>
int sum_with_step(int start, int end, int step) {
    int sum = 0;
    for (int i = start; i <= end; i += step) {
        sum += i;
    }
    return sum;
}
    </code></pre>
</div>

<div class="section" id="section2">
    <h2>2. ∏ (Pi) - Product</h2>
    <h3>Basic Introduction</h3>
    <p>The ∏ (Pi) symbol represents the product of a sequence of numbers, similar to how Σ represents summation.</p>

    <h3>Simple Example</h3>
    <pre><code>
 5
 ∏ i = 1 * 2 * 3 * 4 * 5 = 120
i=1
    </code></pre>
    <p>This means "multiply the values of i, where i goes from 1 to 5".</p>

    <h3>Advanced Explanation</h3>
    <p>Product notation is essential in combinatorics, probability theory, and many areas of advanced mathematics. It's particularly useful for representing factorials and certain types of series.</p>

    <h3>Complex Example: Factorial</h3>
    <p><strong>Mathematical Notation:</strong></p>
    <pre><code>
 n
 ∏ i = n!
i=1
    </code></pre>

    <p><strong>Meaning:</strong> The product of integers from 1 to n, also known as n factorial.</p>

    <p><strong>C Implementation:</strong></p>
    <pre><code>
unsigned long long factorial(int n) {
    unsigned long long result = 1;
    for (int i = 2; i <= n; i++) {
        result *= i;
    }
    return result;
}
    </code></pre>
</div>

<div class="section" id="section3">
    <h2>3. √ - Square Root</h2>
    <h3>Basic Introduction</h3>
    <p>The √ symbol represents the square root of a number. It's the inverse operation of squaring a number.</p>

    <h3>Simple Example</h3>
    <p>√9 = 3, because 3 * 3 = 9</p>

    <h3>Advanced Explanation</h3>
    <p>Square roots are irrational for most numbers, leading to important concepts in number theory and algebra. They're fundamental in geometry, particularly for calculating distances using the Pythagorean theorem.</p>

    <p><strong>C Implementation:</strong></p>
    <pre><code>
#include &lt;math.h&gt;

double square_root(double x) {
    return sqrt(x);
}
<h3>Newton's Method for Square Root</h3>
<p>Newton's method is an iterative process for finding approximations to the square root of a number. This can be particularly useful when you need more control over precision or when a built-in square root function is not available.</p>
<pre><code>
double sqrt_newton(double x, int iterations) {
    double guess = x / 2.0;
    for (int i = 0; i < iterations; i++) {
        guess = (guess + x / guess) / 2.0;
    }
    return guess;
}
</code></pre>
</div>

<div class="section" id="section4">
    <h2>4. ∫ - Integral</h2>
    <h3>Basic Introduction</h3>
    <p>The ∫ symbol represents integration in calculus. It can be thought of as the opposite of differentiation and is often used to calculate areas under curves.</p>

    <h3>Simple Example</h3>
<pre><code>
      1
   ∫  x dx = [x²/2] from 0 to 1 = 1/2
      0
</code></pre>
    <p>This calculates the area under the curve y = x from x = 0 to x = 1.</p>

    <h3>Advanced Explanation</h3>
    <p>Integration is a fundamental concept in calculus with applications in physics, engineering, and many other fields. It's used to solve differential equations, calculate volumes, and much more.</p>

    <p><strong>C Implementation (Numerical Integration - Trapezoidal Rule):</strong></p>
    <pre><code>
double integrate_trapezoidal(double (*f)(double), double a, double b, int n) {
    double h = (b - a) / n;
    double sum = 0.5 * (f(a) + f(b));
    for (int i = 1; i < n; i++) {
        sum += f(a + i * h);
    }
    return sum * h;
}
    </code></pre>
</div>

<div class="section" id="section5">
    <h2>5. d/dx - Derivative</h2>
    <h3>Basic Introduction</h3>
    <p>The d/dx symbol represents differentiation with respect to x. It's used to find the rate of change of a function.</p>

    <h3>Simple Example</h3>
    <pre><code>
d
-- (x²) = 2x
dx
    </code></pre>
    <p>This means "the derivative of x² with respect to x is 2x".</p>

    <h3>Advanced Explanation</h3>
    <p>Differentiation is a key concept in calculus, used to analyze rates of change, find maxima and minima, and solve optimization problems. It's crucial in physics for describing motion and in economics for marginal analysis.</p>

    <p><strong>C Implementation (Numerical Differentiation):</strong></p>
    <pre><code>
double derivative(double (*f)(double), double x, double h) {
    return (f(x + h) - f(x - h)) / (2 * h);
}
    </code></pre>
</div>

<div class="section" id="section6">
    <h2>6. lim - Limit</h2>
    <h3>Basic Introduction</h3>
    <p>The lim symbol represents the limit of a function as the input approaches a specific value.</p>

    <h3>Simple Example</h3>
    <pre><code>
    lim (1/x) = 0
x -> ∞
    </code></pre>
    <p>This means "as x approaches infinity, 1/x approaches 0".</p>

    <h3>Advanced Explanation</h3>
    <p>Limits are fundamental in calculus, used to define continuity, derivatives, and integrals. They're crucial for understanding function behavior near critical points or asymptotes.</p>

    <p><strong>C Implementation (Limit Approximation):</strong></p>
    <pre><code>
double limit_approx(double (*f)(double), double a, double epsilon) {
    return f(a + epsilon);
}
    </code></pre>
</div>

<div class="section" id="section7">
    <h2>7. ∀ - For All</h2>
    <h3>Basic Introduction</h3>
    <p>The ∀ symbol means "for all" or "for every" in mathematical logic and set theory.</p>

    <h3>Simple Example</h3>
    <p>∀x (x² ≥ 0) means "for all x, x squared is greater than or equal to zero".</p>

    <h3>Advanced Explanation</h3>
    <p>This universal quantifier is used in formal logic, set theory, and mathematical proofs. It's often paired with the existential quantifier (∃) in complex logical statements.</p>

    <p><strong>C Implementation (conceptual):</strong></p>
    <pre><code>
int for_all(int* set, int size, int (*predicate)(int)) {
    for (int i = 0; i < size; i++) {
        if (!predicate(set[i])) return 0;
    }
    return 1;
}

// Usage example
int is_positive(int x) { return x > 0; }
int result = for_all(my_array, array_size, is_positive);
    </code></pre>
</div>

<div class="section" id="section8">
    <h2>8. {…} - Set Notation</h2>
    <h3>Basic Introduction</h3>
    <p>Curly braces {} are used to denote sets, which are collections of distinct objects.</p>

    <h3>Simple Example</h3>
    <p>{1, 2, 3, 4, 5} represents a set containing the first five positive integers.</p>

    <h3>Advanced Explanation</h3>
    <p>Set notation is fundamental in mathematics for describing collections of objects. It's used extensively in set theory, algebra, and computer science, especially in describing data structures.</p>

    <p><strong>C Implementation (using a simple array):</strong></p>
    <pre><code>
#include &lt;stdio.h&gt;

void print_set(int* set, int size) {
    printf("{");
    for (int i = 0; i < size; i++) {
        printf("%d", set[i]);
        if (i < size - 1) printf(", ");
    }
    printf("}\n");
}

// Usage
int my_set[] = {1, 2, 3, 4, 5};
print_set(my_set, 5);
    </code></pre>
</div>

<div class="section" id="section9">
    <h2>9. ∈ - Element of</h2>
    <h3>Basic Introduction</h3>
    <p>The ∈ symbol means "is an element of" or "belongs to" a set.</p>

    <h3>Simple Example</h3>
    <p>If S = {1, 2, 3}, then 2 ∈ S means "2 is an element of set S".</p>

    <h3>Advanced Explanation</h3>
    <p>This symbol is crucial in set theory for describing relationships between elements and sets. It's used in defining sets, proving set properties, and in many areas of discrete mathematics.</p>

    <p><strong>C Implementation:</strong></p>
    <pre><code>
int is_element_of(int element, int* set, int size) {
    for (int i = 0; i < size; i++) {
        if (set[i] == element) return 1;
    }
    return 0;
}

// Usage
int my_set[] = {1, 2, 3, 4, 5};
int result = is_element_of(3, my_set, 5);  // Returns 1 (true)
    </code></pre>
</div>

<div class="section" id="section10">
    <h2>10. { | property} - Set Builder Notation</h2>
    <h3>Basic Introduction</h3>
    <p>Set builder notation describes a set by stating a property that its members must satisfy.</p>

    <h3>Simple Example</h3>
    <p>{x | x is an even number less than 10} = {2, 4, 6, 8}</p>

    <h3>Advanced Explanation</h3>
    <p>This notation is powerful for defining sets based on properties rather than listing elements. It's widely used in mathematics to concisely describe infinite sets or sets with complex membership criteria.</p>

    <p><strong>C Implementation (conceptual):</strong></p>
    <pre><code>
#include &lt;stdlib.h&gt;

int* build_set(int max, int (*property)(int), int* size) {
    int* set = malloc(max * sizeof(int));
    *size = 0;
    for (int i = 0; i < max; i++) {
        if (property(i)) {
            set[(*size)++] = i;
        }
    }
    return set;
}

// Usage example
int is_even_less_than_10(int x) { return x % 2 == 0 && x < 10; }
int size;
int* even_set = build_set(10, is_even_less_than_10, &size);
    </code></pre>
</div>

<div class="section" id="section11">
    <h2>11. ⊆ - Subset</h2>
    <h3>Basic Introduction</h3>
    <p>The ⊆ symbol means "is a subset of". A set A is a subset of set B if every element of A is also an element of B.</p>

    <h3>Simple Example</h3>
    <p>If A = {1, 2} and B = {1, 2, 3, 4}, then A ⊆ B.</p>

    <h3>Advanced Explanation</h3>
    <p>The subset relationship is fundamental in set theory and is used extensively in proofs and in defining relationships between sets. It's closely related to the concepts of power sets and set inclusion.</p>

    <p><strong>C Implementation:</strong></p>
    <pre><code>
int is_subset(int* setA, int sizeA, int* setB, int sizeB) {
    for (int i = 0; i < sizeA; i++) {
        if (!is_element_of(setA[i], setB, sizeB)) return 0;
    }
    return 1;
}

// Usage
int setA[] = {1, 2};
int setB[] = {1, 2, 3, 4};
int result = is_subset(setA, 2, setB, 4);  // Returns 1 (true)
    </code></pre>
</div>

<div class="section" id="section12">
    <h2>12. ∪ - Union</h2>
    <h3>Basic Introduction</h3>
    <p>The ∪ symbol represents the union of sets. The union of sets A and B is the set of elements that are in A, in B, or in both A and B.</p>

    <h3>Simple Example</h3>
    <p>If A = {1, 2, 3} and B = {3, 4, 5}, then A ∪ B = {1, 2, 3, 4, 5}</p>

    <h3>Advanced Explanation</h3>
    <p>Union is a fundamental set operation used in set theory, logic, and computer science. It's essential in database operations, algorithm design, and in solving problems involving multiple sets.</p>

    <p><strong>C Implementation:</strong></p>
    <pre><code>
#include &lt;stdlib.h&gt;

int* union_sets(int* setA, int sizeA, int* setB, int sizeB, int* sizeResult) {
    int* result = malloc((sizeA + sizeB) * sizeof(int));
    *sizeResult = 0;
    
    // Add all elements from set A
    for (int i = 0; i < sizeA; i++) {
        result[(*sizeResult)++] = setA[i];
    }
    
    // Add elements from set B that are not in A
    for (int i = 0; i < sizeB; i++) {
        if (!is_element_of(setB[i], setA, sizeA)) {
            result[(*sizeResult)++] = setB[i];
        }
    }
    
    return result;
}

// Usage
int setA[] = {1, 2, 3};
int setB[] = {3, 4, 5};
int sizeResult;
int* unionSet = union_sets(setA, 3, setB, 3, &sizeResult);
    </code></pre>
</div>

<div class="section" id="section13">
    <h2>13. ∩ - Intersection</h2>
    <h3>Basic Introduction</h3>
    <p>The ∩ symbol represents the intersection of sets. The intersection of sets A and B is the set of elements that are in both A and B.</p>

    <h3>Simple Example</h3>
    <p>If A = {1, 2, 3, 4} and B = {3, 4, 5, 6}, then A ∩ B = {3, 4}</p>

    <h3>Advanced Explanation</h3>
    <p>Intersection is a fundamental set operation used in set theory, logic, and database operations. It's crucial in finding common elements between sets and in defining relationships between different sets.</p>

    <p><strong>C Implementation:</strong></p>
    <pre><code>
int* intersection(int* setA, int sizeA, int* setB, int sizeB, int* sizeResult) {
    int* result = malloc(((sizeA < sizeB) ? sizeA : sizeB) * sizeof(int));
    *sizeResult = 0;
    
    for (int i = 0; i < sizeA; i++) {
        if (is_element_of(setA[i], setB, sizeB)) {
            result[(*sizeResult)++] = setA[i];
        }
    }
    
    return result;
}
    </code></pre>
</div>

<div class="section" id="section14">
    <h2>14. ∂ - Partial Derivative</h2>
    <h3>Basic Introduction</h3>
    <p>The ∂ symbol represents a partial derivative, which is the derivative of a function with respect to one variable, treating other variables as constants.</p>

    <h3>Simple Example</h3>
    <p>If f(x, y) = x² + xy, then ∂f/∂x = 2x + y</p>

    <h3>Advanced Explanation</h3>
    <p>Partial derivatives are crucial in multivariable calculus, used to analyze functions of several variables. They're fundamental in physics, engineering, and economics for studying rates of change in complex systems.</p>

    <p><strong>C Implementation (numerical approximation):</strong></p>
    <pre><code>
double partial_derivative(double (*f)(double, double), double x, double y, double h, int respect_to_x) {
    if (respect_to_x) {
        return (f(x + h, y) - f(x - h, y)) / (2 * h);
    } else {
        return (f(x, y + h) - f(x, y - h)) / (2 * h);
    }
}
    </code></pre>
</div>

<div class="section" id="section15">
    <h2>15. ∇ - Gradient</h2>
    <h3>Basic Introduction</h3>
    <p>The ∇ (nabla) symbol represents the gradient of a scalar function, which is a vector of all its partial derivatives.</p>

    <h3>Simple Example</h3>
    <p>If f(x, y) = x² + xy + y², then ∇f = (2x + y, x + 2y)</p>

    <h3>Advanced Explanation</h3>
    <p>The gradient is a key concept in vector calculus, crucial for optimization problems, potential theory in physics, and machine learning algorithms like gradient descent.</p>

    <p><strong>C Implementation (2D gradient):</strong></p>
    <pre><code>
typedef struct {
    double x;
    double y;
} Vector2D;

Vector2D gradient(double (*f)(double, double), double x, double y, double h) {
    Vector2D grad;
    grad.x = partial_derivative(f, x, y, h, 1);
    grad.y = partial_derivative(f, x, y, h, 0);
    return grad;
}
    </code></pre>
</div>

<div class="section" id="section16">
    <h2>16. ≈ - Approximately Equal</h2>
    <h3>Basic Introduction</h3>
    <p>The ≈ symbol means "approximately equal to" and is used when two values are close but not exactly the same.</p>

    <h3>Simple Example</h3>
    <p>π ≈ 3.14159</p>

    <h3>Advanced Explanation</h3>
    <p>This concept is crucial in numerical analysis, physics, and engineering where exact values are often impossible or impractical to compute. It's also important in defining limits and in computational approximations.</p>

    <p><strong>C Implementation:</strong></p>
    <pre><code>
#include &lt;math.h&gt;

int approximately_equal(double a, double b, double epsilon) {
    return fabs(a - b) < epsilon;
}
    </code></pre>
</div>

<div class="section" id="section17">
    <h2>17. ∞ - Infinity</h2>
    <h3>Basic Introduction</h3>
    <p>The ∞ symbol represents infinity, a concept of something without any limit.</p>

    <h3>Simple Example</h3>
    <p>The set of all positive integers: {1, 2, 3, ...} → ∞</p>

    <h3>Advanced Explanation</h3>
    <p>Infinity is a profound concept in mathematics, used in calculus for limits, in set theory for describing infinite sets, and in topology. It's crucial for understanding asymptotic behavior and in defining certain mathematical structures.</p>

    <p><strong>C Implementation (representation using limits):</strong></p>
    <pre><code>
#include &lt;float.h&gt;

#define INFINITY DBL_MAX

double approach_infinity(int n) {
    return 1.0 / (1.0 / n);
}
    </code></pre>
</div>

<div class="section" id="section18">
    <h2>18. ∃ - There Exists</h2>
    <h3>Basic Introduction</h3>
    <p>The ∃ symbol means "there exists" or "there is at least one" in mathematical logic.</p>

    <h3>Simple Example</h3>
    <p>∃x (x² = 4) means "there exists an x such that x squared equals 4"</p>

    <h3>Advanced Explanation</h3>
    <p>This existential quantifier is crucial in logic and set theory, often used in conjunction with the universal quantifier (∀) to form complex logical statements and in mathematical proofs.</p>
    <p><strong>C Implementation (conceptual):</strong></p>
    <pre><code>
int there_exists(int* set, int size, int (*predicate)(int)) {
    for (int i = 0; i < size; i++) {
        if (predicate(set[i])) return 1;
    }
    return 0;
}

// Usage example
int is_even(int x) { return x % 2 == 0; }
int result = there_exists(my_array, array_size, is_even);
    </code></pre>
</div>

<div class="section" id="section19">
    <h2>19. ⇒ and ⇔ - Implication and Equivalence</h2>
    <h3>Basic Introduction</h3>
    <p>⇒ means "implies" or "if...then"</p>
    <p>⇔ means "if and only if" or "is equivalent to"</p>

    <h3>Simple Example</h3>
    <p>A ⇒ B: "If it's raining (A), then the ground is wet (B)"</p>
    <p>A ⇔ B: "A triangle is equilateral if and only if all its angles are 60°"</p>

    <h3>Advanced Explanation</h3>
    <p>These logical connectives are fundamental in mathematical logic, used extensively in proofs, definitions, and in formalizing mathematical statements. They're crucial in understanding the relationships between different mathematical conditions or statements.</p>

    <p>C Implementation (conceptual boolean logic)</p>
    <pre><code>
int implies(int a, int b) {
    return !a || b;  // equivalent to "not A or B"
}

int iff(int a, int b) {
    return (a && b) || (!a && !b);  // both true or both false
}
    </code></pre>
</div>


<h3>Note: Adding new sections specifically relevant to deep learning below.</h3>


<div class="section" id="section20">
    <h2>20. Matrix Operations</h2>
    <h3>Basic Introduction</h3>
    <p>
Matrices are rectangular arrays of numbers, symbols, or expressions arranged in rows and columns. They are fundamental in deep learning for representing and manipulating data and model parameters.
</p>

    <h3>Simple Example</h3>
    <p>
A 2x3 matrix: 
</br>
A = [ 1 2 3 ]
    [ 4 5 6 ]
</p>

    <h3>Advanced Explanation</h3>
    <p>
Matrix operations like addition, multiplication, and transposition are crucial in deep learning for tasks such as feature transformation, weight updates, and backpropagation.
</p>

    <h3>Key Notations</h3>
    <p>A^T: Transpose of matrix A</p>
    <p>AB: Matrix multiplication of A and B</p>
    <p>A ⊙ B: Hadamard (element-wise) product of A and B</p>


    <h3>C Implementation (basic matrix operations)</h3>
    <pre><code>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct {
    int rows, cols;
    double** data;
} Matrix;

Matrix create_matrix(int rows, int cols) {
    Matrix m = {rows, cols, malloc(rows * sizeof(double*))};
    for (int i = 0; i < rows; i++) {
        m.data[i] = calloc(cols, sizeof(double));
    }
    return m;
}

Matrix matrix_multiply(Matrix A, Matrix B) {
    if (A.cols != B.rows) {
        printf("Error: incompatible dimensions\n");
        exit(1);
    }
    Matrix C = create_matrix(A.rows, B.cols);
    for (int i = 0; i < A.rows; i++) {
        for (int j = 0; j < B.cols; j++) {
            for (int k = 0; k < A.cols; k++) {
                C.data[i][j] += A.data[i][k] * B.data[k][j];
            }
        }
    }
    return C;
}

// Other operations like addition, transposition can be implemented similarly
void free_matrix(Matrix m) {
    for (int i = 0; i < m.rows; i++) {
        free(m.data[i]);
    }
    free(m.data);
}

// Usage example
Matrix A = create_matrix(2, 3);
// Use matrix A for operations...
free_matrix(A); // Remember to free the memory
    </code></pre>
</div>

<div class="section" id="section21">
    <h2>21. Partial Derivatives and Gradients in Neural Networks</h2>
    <h3>Basic Introduction</h3>
    <p>In deep learning, partial derivatives and gradients are used to compute how the loss function changes with respect to each model parameter.</p>

    <h3>Simple Example</h3>
    <p>For a loss function L(w, b) where w is a weight and b is a bias:</p>
    <p>∂L/∂w represents how L changes with respect to w</p>
    <p>∂L/∂b represents how L changes with respect to b</p>

    <h3>Advanced Explanation</h3>
    <p>The gradient of the loss function with respect to all parameters forms the basis of gradient descent optimization in neural networks. Backpropagation efficiently computes these gradients.</p>

    <h3>Key Notation</h3>
    <p>∇L = [∂L/∂w₁, ∂L/∂w₂, ..., ∂L/∂wn, ∂L/∂b]</p>

    <h3>C Implementation (simple gradient descent)</h3>
    <pre><code>
void gradient_descent(double *w, double *b, double learning_rate, int iterations) {
    for (int i = 0; i < iterations; i++) {
        double dL_dw = compute_gradient_w(*w, *b);  // Compute ∂L/∂w
        double dL_db = compute_gradient_b(*w, *b);  // Compute ∂L/∂b
        *w -= learning_rate * dL_dw;
        *b -= learning_rate * dL_db;
    }
}
    </code></pre>
</div>

<div class="section" id="section22">
    <h2>22. Activation Functions</h2>
    <h3>Basic Introduction</h3>
    <p>Activation functions introduce non-linearity into neural networks, allowing them to learn complex patterns.</p>

    <h3>Common Activation Functions</h3>
    <p>1. Sigmoid: σ(x) = 1 / (1 + e^(-x))</p>
    <p>2. ReLU: f(x) = max(0, x)</p>
    <p>3. Tanh: tanh(x) = (e^x - e^(-x)) / (e^x + e^(-x))</p>

    <h3>Advanced Explanation</h3>
    <p>Choice of activation functions affects the network's ability to learn and can help mitigate issues like vanishing gradients.</p>

    <h3>C Implementation (activation functions)</h3>
    <pre><code>
#include &lt;math.h&gt;

double sigmoid(double x) {
    return 1.0 / (1.0 + exp(-x));
}

double relu(double x) {
    return (x > 0) ? x : 0;
}

double tanh_activation(double x) {
    return tanh(x);
}
    </code></pre>
</div>

<div class="section" id="section23">
    <h2>23. Probability and Statistics in Machine Learning</h2>
    <h3>Basic Introduction</h3>
    <p>Probability theory underpins many machine learning concepts, from loss functions to generative models.</p>

    <h3>Key Concepts</h3>
    <p>- P(A|B): Conditional probability of A given B</p>
    <p>- E[X]: Expected value of random variable X</p>
    <p>- Var(X): Variance of X</p>

    <h3>Advanced Explanation</h3>
    <p>Concepts like maximum likelihood estimation, Bayesian inference, and information theory are crucial in understanding and developing machine learning algorithms.</p>

    <h3>C Implementation (basic probability calculations)</h3>
    <pre><code>
double expected_value(double *values, double *probabilities, int n) {
    double E = 0;
    for (int i = 0; i < n; i++) {
        E += values[i] * probabilities[i];
    }
    return E;
}

double variance(double *values, double *probabilities, int n) {
    double E = expected_value(values, probabilities, n);
    double Var = 0;
    for (int i = 0; i < n; i++) {
        Var += probabilities[i] * pow(values[i] - E, 2);
    }
    return Var;
}
    </code></pre>
</div>

<div class="section" id="section24">
    <h2>24. Optimization Techniques</h2>
    <h3>Basic Introduction</h3>
    <p>Optimization algorithms are used to minimize the loss function in machine learning models.</p>

    <h3>Key Concepts</h3>
    <p>- Gradient Descent: w = w - η∇L</p>
    <p>- Stochastic Gradient Descent (SGD)</p>
    <p>- Adam Optimizer</p>

    <h3>Advanced Explanation</h3>
    <p>Advanced optimization techniques like Adam combine ideas from momentum and adaptive learning rates to efficiently train deep neural networks.</p>

    <h3>C Implementation (simple SGD)</h3>
    <pre><code>
void sgd(double *w, double *x, double y, double learning_rate, int features) {
    double prediction = 0;
    for (int i = 0; i < features; i++) {
        prediction += w[i] * x[i];
    }
    double error = prediction - y;
    for (int i = 0; i < features; i++) {
        w[i] -= learning_rate * error * x[i];
    }
}
    </code></pre>
</div>
<div id="section25" class="section">
    <h2>25. Trigonometric Functions</h2>
    <h3>Basic Introduction</h3>
    <p>Trigonometric functions are fundamental in mathematics and have numerous applications in computer science, particularly in graphics, physics simulations, and signal processing.</p>

    <h3>Key Concepts</h3>
    <ul>
        <li>θ (theta): Represents an angle in radians or degrees</li>
        <li>sin(θ): Sine function</li>
        <li>cos(θ): Cosine function</li>
        <li>tan(θ): Tangent function</li>
    </ul>

    <h3>Advanced Explanation</h3>
    <p>These functions describe the relationships between angles and the ratios of sides in right-angled triangles. They are periodic functions with various important properties used in wave analysis, rotation calculations, and more.</p>

    <p>The symbol θ (theta) is commonly used to represent an angle. In trigonometry, angles are typically measured in radians, where 2π radians equal 360 degrees. However, many programming languages use degrees for input, so conversion between degrees and radians is often necessary.</p>

    <div class="example">
        <h4>Example: Angle Conversion and Trigonometric Calculations</h4>
        <pre><code>
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

#define PI 3.14159265358979323846

// Convert degrees to radians
double deg_to_rad(double degrees) {
    return degrees * PI / 180.0;
}

// Convert radians to degrees
double rad_to_deg(double radians) {
    return radians * 180.0 / PI;
}

int main() {
    double angle_deg = 45.0;
    double angle_rad = deg_to_rad(angle_deg);

    printf("Angle: %.2f degrees = %.4f radians\n", angle_deg, angle_rad);
    printf("sin(%.2f°) = %.4f\n", angle_deg, sin(angle_rad));
    printf("cos(%.2f°) = %.4f\n", angle_deg, cos(angle_rad));
    printf("tan(%.2f°) = %.4f\n", angle_deg, tan(angle_rad));

    return 0;
}
        </code></pre>
        <p>This example demonstrates angle conversion and basic trigonometric calculations. Note that C math functions expect angles in radians, so we convert from degrees to radians before calculation.</p>
    </div>

    <div class="example">
        <h4>Example: Calculating points on a circle</h4>
        <pre><code>
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

#define PI 3.14159265358979323846

typedef struct {
    double x;
    double y;
} Point;

Point point_on_circle(double radius, double angle_degrees) {
    double angle_radians = angle_degrees * PI / 180.0;
    Point p;
    p.x = radius * cos(angle_radians);
    p.y = radius * sin(angle_radians);
    return p;
}

void print_points_on_circle(double radius, int num_points) {
    printf("Points on a circle with radius %.2f:\n", radius);
    for (int i = 0; i < num_points; i++) {
        double angle = (360.0 / num_points) * i;
        Point p = point_on_circle(radius, angle);
        printf("  Angle: %.2f°, Point: (%.2f, %.2f)\n", angle, p.x, p.y);
    }
}

int main() {
    print_points_on_circle(5.0, 8);
    return 0;
}
        </code></pre>
        <p>This example calculates points on a circle using trigonometric functions. It demonstrates how sin(θ) and cos(θ) are used to convert polar coordinates (radius and angle) to Cartesian coordinates (x and y).</p>
    </div>

    <div class="application">
        <h4>Application: 2D Rotation</h4>
        <p>Trigonometric functions are crucial in computer graphics for rotating objects. Here's an improved example that rotates a set of points around the origin:</p>
        <pre><code>
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

#define PI 3.14159265358979323846

typedef struct {
    double x;
    double y;
} Point;

void rotate_point(Point* p, double angle_degrees) {
    double angle_radians = angle_degrees * PI / 180.0;
    double x = p->x;
    double y = p->y;
    p->x = x * cos(angle_radians) - y * sin(angle_radians);
    p->y = x * sin(angle_radians) + y * cos(angle_radians);
}

void print_point(Point p) {
    printf("(%.2f, %.2f)", p.x, p.y);
}

int main() {
    Point points[] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
    int num_points = sizeof(points) / sizeof(points[0]);
    double rotation_angle = 45.0;

    printf("Original points:\n");
    for (int i = 0; i < num_points; i++) {
        print_point(points[i]);
        printf("\n");
    }

    printf("\nRotating by %.2f degrees...\n\n", rotation_angle);

    for (int i = 0; i < num_points; i++) {
        rotate_point(&points[i], rotation_angle);
    }

    printf("Rotated points:\n");
    for (int i = 0; i < num_points; i++) {
        print_point(points[i]);
        printf("\n");
    }

    return 0;
}
        </code></pre>
        <p>This example demonstrates how to use trigonometric functions to rotate points around the origin. The rotation matrix used is derived from the following trigonometric identities:
           <br>x' = x cos(θ) - y sin(θ)
           <br>y' = x sin(θ) + y cos(θ)
           <br>Where (x, y) is the original point, (x', y') is the rotated point, and θ is the rotation angle.</p>
    </div>
</div>

    <div id="section26" class="section">
        <h2>26. Euler's Formula</h2>
        <h3>Basic Introduction</h3>
        <p>Euler's formula, e<sup>ix</sup> = cos(x) + i sin(x), establishes a profound connection between exponential and trigonometric functions.</p>

        <h3>Key Concept</h3>
        <p>e<sup>iπ</sup> + 1 = 0</p>

        <h3>Advanced Explanation</h3>
        <p>This formula is fundamental in complex analysis and has applications in signal processing, particularly in Fourier transforms. It provides a way to represent rotations and periodic phenomena using complex exponentials.</p>

        <div class="example">
            <h4>Example: Complex number rotation</h4>
            <pre><code>
#include &lt;complex.h&gt;

double complex rotate_complex(double complex z, double angle_degrees) {
    double angle_radians = angle_degrees * M_PI / 180.0;
    return z * cexp(I * angle_radians);
}
            </code></pre>
        </div>

        <div class="application">
            <h4>Application: Signal Processing</h4>
            <p>Euler's formula is crucial in the discrete Fourier transform:</p>
            <pre><code>
void dft(double complex* x, int N) {
    for (int k = 0; k < N; k++) {
        x[k] = 0;
        for (int n = 0; n < N; n++) {
            x[k] += x[n] * cexp(-2 * M_PI * I * k * n / N);
        }
    }
}
            </code></pre>

<h3>Complex Numbers in Polar Form</h3>
<p>A complex number can be represented in polar form as:</p>
<pre><code>
z = r * (cos(θ) + i * sin(θ))
</code></pre>
<p>Where:</p>
<ul>
    <li>r is the magnitude (distance from the origin)</li>
    <li>θ (theta) is the angle formed with the positive real axis, known as the argument</li>
</ul>
<p>This form is useful for multiplying and dividing complex numbers, as it simplifies the calculation of products and quotients.</p>

<p><strong>Example:</strong></p>
<pre><code>
double magnitude = cabs(z);
double angle = carg(z);
double complex polar_form = magnitude * (cos(angle) + I * sin(angle));
</code></pre>
        </div>
    </div>
<div id="section27" class="section">
<h2>27. Superscript Notation (i) and [l]</h2>

<h3>Basic Introduction</h3>
<p>In machine learning notation:</p>
<ul>
    <li>Superscript (i) denotes the i-th training example</li>
    <li>Superscript [l] denotes the l-th layer of a neural network</li>
</ul>

<h3>Advanced Explanation</h3>
<p>This notation helps distinguish between different examples in a dataset and different layers in a neural network, which is crucial for understanding the flow of data and computations.</p>

<h3>C Implementation</h3>
<pre><code class="language-c">
typedef struct {
    double* features;
    double label;
} Example;

typedef struct {
    double** weights;
    double* biases;
    int units;
} Layer;

// Usage
Example training_example[m];  // m examples
Layer network[L];  // L layers

// Accessing i-th example, l-th layer
double feature_j_of_example_i = training_example[i].features[j];
double weight_jk_of_layer_l = network[l].weights[j][k];
</code></pre>
</div>

<div id="section28" class="section">
<h2>28. Size Notations (m, nx, ny, n[l]h, L)</h2>

<h3>Basic Introduction</h3>
<ul>
    <li>m: number of examples in the dataset</li>
    <li>nx: input size</li>
    <li>ny: output size (or number of classes)</li>
    <li>n[l]h: number of hidden units of the l-th layer</li>
    <li>L: number of layers in the network</li>
</ul>

<h3>Advanced Explanation</h3>
<p>These notations help define the structure of the neural network and the dataset. They're crucial for setting up the correct dimensions of weight matrices and bias vectors.</p>

<h3>C Implementation</h3>
<pre><code class="language-c">
#define M 1000  // Number of examples
#define NX 784  // Input size (e.g., for MNIST)
#define NY 10   // Output size (e.g., 10 classes for MNIST)
#define L 3     // Number of layers

int n_h[L] = {128, 64, NY};  // Hidden units per layer
</code></pre>
</div>

<div id="section29" class="section">
<h2>29. Matrix and Vector Notations (X, x(i), Y, y(i), W[l], b[l], ŷ)</h2>

<h3>Basic Introduction</h3>
<ul>
    <li>X ∈ R^(nx×m): input matrix</li>
    <li>x(i) ∈ R^nx: i-th example as a column vector</li>
    <li>Y ∈ R^(ny×m): label matrix</li>
    <li>y(i) ∈ R^ny: output label for the i-th example</li>
    <li>W[l]: weight matrix of layer l</li>
    <li>b[l]: bias vector of layer l</li>
    <li>ŷ: predicted output vector</li>
</ul>

<h3>Advanced Explanation</h3>
<p>These notations represent the core data structures in a neural network. The input matrix X contains all training examples, while Y contains their corresponding labels. W[l] and b[l] are the learnable parameters of the network.</p>

<h3>C Implementation</h3>
<pre><code class="language-c">
#include &lt;stdlib.h&gt;

double** allocate_2d_array(int rows, int cols) {
    double** array = malloc(rows * sizeof(double*));
    for (int i = 0; i < rows; i++) {
        array[i] = malloc(cols * sizeof(double));
    }
    return array;
}

// Usage
double** X = allocate_2d_array(NX, M);
double** Y = allocate_2d_array(NY, M);
double** W[L];
double* b[L];

for (int l = 0; l < L; l++) {
    int next_layer_size = (l == L-1) ? NY : n_h[l+1];
    int this_layer_size = (l == 0) ? NX : n_h[l];
    W[l] = allocate_2d_array(next_layer_size, this_layer_size);
    b[l] = malloc(next_layer_size * sizeof(double));
}

double* y_hat = malloc(NY * sizeof(double));
</code></pre>
</div>

<div id="section30" class="section">
<h2>30. Activation Functions and Forward Propagation</h2>

<h3>Basic Introduction</h3>
<p>Activation functions introduce non-linearity into the network. Common ones include ReLU, sigmoid, and tanh.</p>
<p>Forward propagation equation: a = g[l](Wxx(i) + b1) = g[l](z1)</p>

<h3>Advanced Explanation</h3>
<p>The activation function g[l] is applied element-wise to the linear transformation of the input. This process is repeated layer by layer in forward propagation.</p>

<h3>C Implementation</h3>
<pre><code class="language-c">
#include &lt;math.h&gt;

double relu(double x) {
    return x > 0 ? x : 0;
}

double sigmoid(double x) {
    return 1 / (1 + exp(-x));
}

void forward_propagation(double* input, double** W, double* b, int input_size, int output_size, double* output) {
    for (int i = 0; i < output_size; i++) {
        double z = 0;
        for (int j = 0; j < input_size; j++) {
            z += W[i][j] * input[j];
        }
        z += b[i];
        output[i] = relu(z);  // Using ReLU activation
    }
}
</code></pre>
</div>

<div id="section31" class="section">
<h2>31. Cost Functions J(x, W, b, y) or J(ŷ, y)</h2>

<h3>Basic Introduction</h3>
<p>Cost functions measure the difference between predicted and actual outputs. Common ones include:</p>
<ul>
    <li>Cross-entropy: JCE(ŷ, y) = -Σ y(i) log ŷ(i)</li>
    <li>Mean squared error: J1(ŷ, y) = Σ |y(i) - ŷ(i)|^2</li>
</ul>

<h3>Advanced Explanation</h3>
<p>Cost functions guide the optimization process. The goal is to minimize the cost function by adjusting the network's parameters (weights and biases).</p>

<h3>C Implementation</h3>
<pre><code class="language-c">
#include &lt;math.h&gt;

double cross_entropy_loss(double* y_true, double* y_pred, int n) {
    double loss = 0;
    for (int i = 0; i < n; i++) {
        loss -= y_true[i] * log(y_pred[i]);
    }
    return loss;
}

double mean_squared_error(double* y_true, double* y_pred, int n) {
    double loss = 0;
    for (int i = 0; i < n; i++) {
        double diff = y_true[i] - y_pred[i];
        loss += diff * diff;
    }
    return loss / n;
}
</code></pre>

</div>

<div class="section" id="section32">
    <h2>32. Jacobian Matrix (J)</h2>
    <h3>Basic Introduction</h3>
    <p>The Jacobian matrix is a matrix of all first-order partial derivatives of a vector-valued function. It represents how a small change in each input affects each output.</p>

    <h3>Mathematical Notation</h3>
    <pre><code>
        J = 
        [ ∂f₁/∂x₁ ∂f₁/∂x₂ ... ∂f₁/∂xn ]
        [ ∂f₂/∂x₁ ∂f₂/∂x₂ ... ∂f₂/∂xn ]
        [  .       .           .      ]
        [ ∂fm/∂x₁ ∂fm/∂x₂ ... ∂fm/∂xn ]
    </code></pre>

    <h3>Advanced Explanation</h3>
    <p>The Jacobian matrix is crucial in transforming coordinates in multivariable calculus, optimizing multivariable functions, and is widely used in machine learning, particularly in backpropagation for neural networks.</p>

    <h3>C Implementation</h3>
    <pre><code>
// Example function to calculate partial derivatives
double df1_dx1(double x1, double x2) {
    return 2 * x1;  // Example: derivative of f1 = x1^2 + x2
}

double df1_dx2(double x1, double x2) {
    return 1;  // Example: derivative of f1 = x1^2 + x2
}

double** compute_jacobian(double (*f[])(double, double), double x1, double x2, int m, int n) {
    double** J = malloc(m * sizeof(double*));
    for (int i = 0; i < m; i++) {
        J[i] = malloc(n * sizeof(double));
    }
    J[0][0] = df1_dx1(x1, x2);
    J[0][1] = df1_dx2(x1, x2);
    // Add more partial derivatives as necessary
    return J;
}
    </code></pre>
</div>

<div class="section" id="section33">
    <h2>33. Hessian Matrix (H)</h2>
    <h3>Basic Introduction</h3>
    <p>The Hessian matrix is a square matrix of second-order partial derivatives of a scalar-valued function. It is used to analyze the curvature of the function, which is critical in optimization problems.</p>

    <h3>Mathematical Notation</h3>
    <pre><code>
        H = 
        [ ∂²f/∂x₁² ∂²f/∂x₁∂x₂ ... ∂²f/∂xn² ]
        [ ∂²f/∂x₂² ∂²f/∂x₂∂x₁ ... ∂²f/∂xn² ]
        [  .           .           .      ]
        [ ∂²f/∂xn² ∂²f/∂xn∂x₁ ... ∂²f/∂xn² ]
    </code></pre>

    <h3>Advanced Explanation</h3>
    <p>The Hessian is vital in determining the nature of critical points (minima, maxima, or saddle points) and is heavily used in second-order optimization algorithms like Newton's method.</p>

    <h3>C Implementation</h3>
    <pre><code>
// Example second-order partial derivatives
double d2f_dx1dx1(double x1, double x2) {
    return 2;  // Example: second derivative of f = x1^2 + x2 with respect to x1
}

double d2f_dx1dx2(double x1, double x2) {
    return 0;  // Example: mixed derivative of f = x1^2 + x2 with respect to x1 and x2
}

double** compute_hessian(double x1, double x2) {
    double** H = malloc(2 * sizeof(double*));
    for (int i = 0; i < 2; i++) {
        H[i] = malloc(2 * sizeof(double));
    }
    H[0][0] = d2f_dx1dx1(x1, x2);
    H[0][1] = d2f_dx1dx2(x1, x2);
    H[1][0] = H[0][1];  // Hessian is symmetric
    H[1][1] = 0;  // Example: second derivative of f = x1^2 + x2 with respect to x2
    return H;
}
    </code></pre>
</div>

<div class="section" id="section34">
    <h2>34. Eigenvalues and Eigenvectors</h2>
    <h3>Basic Introduction</h3>
    <p>Eigenvalues and eigenvectors are key concepts in linear algebra. An eigenvector of a matrix is a vector that remains parallel to itself after being transformed by the matrix, and the corresponding eigenvalue is a scalar that represents how much the eigenvector is scaled during the transformation.</p>

    <h3>Mathematical Notation</h3>
    <pre><code>
        A * v = λ * v
    </code></pre>
    <p>Where A is a square matrix, v is the eigenvector, and λ (lambda) is the eigenvalue.</p>

    <h3>Advanced Explanation</h3>
    <p>Eigenvalues and eigenvectors are used in many areas including principal component analysis (PCA), stability analysis, and quantum mechanics. They help in simplifying matrix operations and understanding the structure of a matrix.</p>

    <h3>C Implementation</h3>
    <pre><code>
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

void power_iteration(double** A, double* v, int n, int iterations) {
    for (int k = 0; k < iterations; k++) {
        double* w = malloc(n * sizeof(double));
        for (int i = 0; i < n; i++) {
            w[i] = 0;
            for (int j = 0; j < n; j++) {
                w[i] += A[i][j] * v[j];
            }
        }
        // Normalize vector w to become the next eigenvector approximation
        double norm = 0;
        for (int i = 0; i < n; i++) {
            norm += w[i] * w[i];
        }
        norm = sqrt(norm);
        for (int i = 0; i < n; i++) {
            v[i] = w[i] / norm;
        }
        free(w);
    }
}

double compute_eigenvalue(double** A, double* v, int n) {
    double* Av = malloc(n * sizeof(double));
    double eigenvalue = 0;
    for (int i = 0; i < n; i++) {
        Av[i] = 0;
        for (int j = 0; j < n; j++) {
            Av[i] += A[i][j] * v[j];
        }
        eigenvalue += v[i] * Av[i];
    }
    free(Av);
    return eigenvalue;
}
    </code></pre>
</div>


<div class="section" id="section35">
    <h2>35. Matrix Inverses and Determinants</h2>
    <h3>Basic Introduction</h3>
    <p>The inverse of a matrix A is another matrix, denoted A⁻¹, such that A * A⁻¹ = I, where I is the identity matrix. The determinant of a matrix is a scalar value that is a function of the entries of a square matrix and provides important properties of the matrix.</p>

    <h3>Mathematical Notation</h3>
    <pre><code>
        A * A⁻¹ = I
        
        det(A) = ∑ (sign(σ) * a₁σ(1) * a₂σ(2) * ... * anσ(n))
    </code></pre>

    <h3>Advanced Explanation</h3>
    <p>Determinants are used to solve systems of linear equations, compute eigenvalues, and understand matrix properties like invertibility. The inverse matrix is crucial in solving matrix equations and in many algorithms in computer science and data analysis.</p>

    <h3>C Implementation</h3>
    <pre><code>
#include &lt;stdio.h&gt;

double determinant(double** A, int n) {
    if (n == 1) return A[0][0];
    if (n == 2) return A[0][0] * A[1][1] - A[0][1] * A[1][0];

    double det = 0;
    for (int p = 0; p < n; p++) {
        double** submatrix = malloc((n-1) * sizeof(double*));
        for (int i = 1; i < n; i++) {
            submatrix[i-1] = malloc((n-1) * sizeof(double));
            for (int j = 0, col = 0; j < n; j++) {
                if (j == p) continue;
                submatrix[i-1][col++] = A[i][j];
            }
        }
        det += A[0][p] * determinant(submatrix, n-1) * (p % 2 == 0 ? 1 : -1);
        for (int i = 0; i < n-1; i++) free(submatrix[i]);
        free(submatrix);
    }
    return det;
}

void inverse(double** A, double** inverse, int n) {
    double det = determinant(A, n);
    if (det == 0) {
        printf("Singular matrix, no inverse.");
        return;
    }

    // Compute the inverse here (this implementation is non-trivial and can be complex)
    // ...
}
    </code></pre>
</div>


<div class="section" id="section36">
    <h2>36. L'Hôpital's Rule</h2>
    <h3>Basic Introduction</h3>
    <p>L'Hôpital's Rule provides a method to evaluate limits that result in indeterminate forms, such as 0/0 or ∞/∞.</p>

    <h3>Mathematical Notation</h3>
    <pre><code>
        lim (f(x)/g(x)) = lim (f'(x)/g'(x))
        x -> c               x -> c
    </code></pre>
    <p>Provided that the limit on the right-hand side exists.</p>

    <h3>Advanced Explanation</h3>
    <p>L'Hôpital's Rule is useful for calculating difficult limits and appears frequently in calculus, particularly in problems involving asymptotic analysis and optimization.</p>

    <h3>C Implementation</h3>
    <pre><code>
#include &lt;math.h&gt;

double f(double x) {
    return sin(x);
}

double g(double x) {
    return x;
}

double df_dx(double x) {
    return cos(x);
}

double dg_dx(double x) {
    return 1;
}

double lhopital_rule(double x) {
    double numerator = df_dx(x);
    double denominator = dg_dx(x);
    if (denominator == 0) {
        printf("Indeterminate form at x = %.2f\n", x);
        return NAN;
    }
    return numerator / denominator;
}
    </code></pre>
</div>



<div class="section" id="section37">
    <h2>37. Implicit Differentiation</h2>
    <h3>Basic Introduction</h3>
    <p>Implicit differentiation is used when a function is not explicitly solved for one variable in terms of the others, but you still need to find its derivative.</p>

    <h3>Mathematical Notation</h3>
    <pre><code>
        Given: F(x, y) = 0
        Then: dy/dx = - (∂F/∂x) / (∂F/∂y)
    </code></pre>

    <h3>Advanced Explanation</h3>
    <p>Implicit differentiation is particularly useful in situations where solving for one variable explicitly is complex or impossible, such as in many equations in physics and economics.</p>

    <h3>C Implementation</h3>
    <pre><code>
// Example function F(x, y) = x^2 + y^2 - 1 = 0 (circle equation)
double dF_dx(double x, double y) {
    return 2 * x;
}

double dF_dy(double x, double y) {
    return 2 * y;
}

double implicit_derivative(double x, double y) {
    return -dF_dx(x, y) / dF_dy(x, y);
}
    </code></pre>
</div>



<div class="section" id="section38">
    <h2>38. Chain Rule</h2>
    <h3>Basic Introduction</h3>
    <p>The chain rule is a fundamental theorem in calculus used to differentiate composite functions.</p>

    <h3>Mathematical Notation</h3>
    <pre><code>
        If y = f(g(x)), then dy/dx = f'(g(x)) * g'(x)
    </code></pre>

    <h3>Advanced Explanation</h3>
    <p>The chain rule is essential for understanding how to differentiate functions composed of other functions. It is widely used in the backpropagation algorithm in neural networks and in various other optimization techniques.</p>

    <h3>C Implementation</h3>
    <pre><code>
// Example: f(g(x)) where f(u) = u^2 and g(x) = sin(x)
double g(double x) {
    return sin(x);
}

double f(double u) {
    return u * u;
}

double chain_rule(double x) {
    double u = g(x);
    double df_du = 2 * u;
    double dg_dx = cos(x);
    return df_du * dg_dx;
}
    </code></pre>
</div>



<div class="section" id="section39">
    <h2>39. Multivariable Calculus</h2>
    <h3>Basic Introduction</h3>
    <p>Multivariable calculus extends calculus to functions of several variables. It includes concepts like partial derivatives, multiple integrals, and gradient vectors.</p>

    <h3>Key Concepts</h3>
    <ul>
        <li><strong>Partial Derivatives:</strong> Derivatives of functions with respect to one variable, holding others constant.</li>
        <li><strong>Gradient (∇):</strong> A vector that represents the direction and rate of fastest increase of a function.</li>
        <li><strong>Multiple Integrals:</strong> Integrals over more than one variable, used to compute volumes and areas.</li>
    </ul>

    <h3>Advanced Explanation</h3>
    <p>Multivariable calculus is essential in fields such as optimization, physics, and machine learning. It allows for the analysis of systems with multiple changing variables.</p>

    <h3>C Implementation</h3>
    <pre><code>
// Example: Gradient of f(x, y) = x^2 + y^2
double df_dx(double x, double y) {
    return 2 * x;
}

double df_dy(double x, double y) {
    return 2 * y;
}

void compute_gradient(double x, double y, double* gradient) {
    gradient[0] = df_dx(x, y);
    gradient[1] = df_dy(x, y);
}
    </code></pre>
</div>



<div class="section" id="section40">
    <h2>40. Big-O Notation (O)</h2>
    <h3>Basic Introduction</h3>
    <p>Big-O notation describes the upper bound of an algorithm's runtime or space complexity in the worst case, helping to classify algorithms according to how their running time or space requirements grow as the input size grows.</p>

    <h3>Mathematical Notation</h3>
    <pre><code>
        O(f(n)) = { g(n) | there exists constants c > 0 and n₀ ≥ 0 such that 0 ≤ g(n) ≤ c * f(n) for all n ≥ n₀ }
    </code></pre>

    <h3>Advanced Explanation</h3>
    <p>Big-O notation is crucial for analyzing the efficiency of algorithms, particularly in computer science. It helps in making decisions about which algorithms to use based on their performance as the size of the input data grows.</p>

    <h3>C Implementation</h3>
    <pre><code>
// Example: Linear Search O(n)
int linear_search(int* arr, int n, int target) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == target) {
            return i;
        }
    }
    return -1;
}

// Example: Binary Search O(log n)
int binary_search(int* arr, int n, int target) {
    int low = 0, high = n - 1;
    while (low <= high) {
        int mid = (low + high) / 2;
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    return -1;
}
    </code></pre>
</div>


    <div id="resources">
        <h2>Recommended Resources</h2>
        <ul>
            <li><a href="https://www.khanacademy.org/math">Khan Academy - Mathematics</a></li>
            <li><a href="https://ocw.mit.edu/courses/mathematics/">MIT OpenCourseWare - Mathematics</a></li>
        <li><a href="https://cs230.stanford.edu/files/Notation.pdf">cs230 - Standard notations for Deep Learning</a></li>
            <li>"Concrete Mathematics" by Graham, Knuth, and Patashnik</li>
            <li>"Mathematics for Computer Science" by Eric Lehman and Tom Leighton</li>
        </ul>
    </div>

    <script>
        // JavaScript to toggle the navigation menu
        var menuButton = document.getElementById('menuButton');
        var navMenu = document.getElementById('navMenu');
        menuButton.addEventListener('click', function() {
            var isShown = navMenu.classList.contains('show');
            navMenu.classList.toggle('show', !isShown);
        });
    </script>

<hr>
<p>
**This project is not a professional educational tool.** It was created for personal learning and experimentation with mathematical notation and calculus. While the content aims to be accurate and useful, it is not guaranteed to be error-free or comprehensive. Use it at your own risk, and please verify any mathematical or coding implementations independently.
</p>
<p>
For any questions or additional information, you can reach out via alberrod.dev@gmail.com
</p>

</body>
</html>
